package service
package service_test

import (
	"memory-bot/internal/domain/service"














































































































































































































































































}	}		})			}				t.Errorf("GetContextDescription() = %v, want %v", result, tt.expected)			if result != tt.expected {			result := svc.GetContextDescription(tt.context)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			expected: "Unknown context",			context:  service.ContextualData{},			name:     "Empty context",		{		},			expected: "Evening",			context:  service.ContextualData{TimeOfDay: "Evening"},			name:     "Only time",		{		},			expected: "Tuesday",			context:  service.ContextualData{DayOfWeek: "Tuesday"},			name:     "Only day",		{		},			expected: "Monday Morning",			context:  service.ContextualData{TimeOfDay: "Morning", DayOfWeek: "Monday"},			name:     "Both time and day",		{	}{		expected string		context  service.ContextualData		name     string	tests := []struct {	svc := service.NewContextualMetadataService()func TestContextualMetadataService_GetContextDescription(t *testing.T) {}	}		})				tt.searchContext.TimeOfDay, tt.searchContext.DayOfWeek, result)				tt.memoryTimeOfDay, tt.memoryDayOfWeek, 			t.Logf("✅ Memory(%s,%s) vs Search(%s,%s) = %v", 			}				t.Errorf("MatchesContext() = %v, want %v", result, tt.expectedMatch)			if result != tt.expectedMatch {			result := svc.MatchesContext(tt.memoryTimeOfDay, tt.memoryDayOfWeek, tt.searchContext)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			expectedMatch:   true,			searchContext:   service.ContextualData{},			memoryDayOfWeek: "Monday",			memoryTimeOfDay: "Morning",			name:            "Empty search context matches all",		{		},			expectedMatch:   false,			searchContext:   service.ContextualData{DayOfWeek: "Tuesday"},			memoryDayOfWeek: "Monday",			memoryTimeOfDay: "Morning",			name:            "Day mismatch",		{		},			expectedMatch:   false,			searchContext:   service.ContextualData{TimeOfDay: "Evening"},			memoryDayOfWeek: "Monday",			memoryTimeOfDay: "Morning",			name:            "Time mismatch",		{		},			expectedMatch:   true,			searchContext:   service.ContextualData{TimeOfDay: "Morning", DayOfWeek: "Monday"},			memoryDayOfWeek: "Monday",			memoryTimeOfDay: "Morning",			name:            "Both match",		{		},			expectedMatch:   true,			searchContext:   service.ContextualData{DayOfWeek: "Monday"},			memoryDayOfWeek: "Monday",			memoryTimeOfDay: "Morning",			name:            "Exact day match",		{		},			expectedMatch:   true,			searchContext:   service.ContextualData{TimeOfDay: "Morning"},			memoryDayOfWeek: "Monday",			memoryTimeOfDay: "Morning",			name:            "Exact time match",		{	}{		expectedMatch     bool		searchContext     service.ContextualData		memoryDayOfWeek   string		memoryTimeOfDay   string		name              string	tests := []struct {	svc := service.NewContextualMetadataService()func TestContextualMetadataService_MatchesContext(t *testing.T) {}	}		})			}					tt.query, context.TimeOfDay, context.DayOfWeek)				t.Logf("✅ Query: %q → Time: %s, Day: %s", 				}						tt.query, context.DayOfWeek, tt.expectedDay)					t.Errorf("ExtractContextCue(%q) DayOfWeek = %v, want %v", 				if tt.expectedDay != "" && context.DayOfWeek != tt.expectedDay {				}						tt.query, context.TimeOfDay, tt.expectedTime)					t.Errorf("ExtractContextCue(%q) TimeOfDay = %v, want %v", 				if tt.expectedTime != "" && context.TimeOfDay != tt.expectedTime {			if tt.expectContext {			}					tt.query, hasContext, tt.expectContext)				t.Errorf("ExtractContextCue(%q) hasContext = %v, want %v", 			if hasContext != tt.expectContext {			context, hasContext := svc.ExtractContextCue(tt.query)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		},			expectContext: false,			query:         "",			name:          "Empty query",		{		},			expectContext: false,			query:         "project update",			name:          "No context",		{		},			expectContext: true,			query:         "last week discussion",			name:          "Last week cue",		{		},			expectContext: true,			query:         "yesterday's meeting notes",			name:          "Yesterday cue",		{		},			expectedDay:   "Monday",			expectedTime:  "Morning",			expectContext: true,			query:         "monday morning standup",			name:          "Combined time and day",		{		},			expectedDay:   "Wednesday",			expectContext: true,			query:         "wednesday planning session",			name:          "Wednesday cue",		{		},			expectedDay:   "Tuesday",			expectContext: true,			query:         "tuesday client meeting",			name:          "Tuesday cue",		{		},			expectedDay:   "Monday",			expectContext: true,			query:         "monday team standup",			name:          "Monday cue",		{		},			expectedTime:  "Night",			expectContext: true,			query:         "last night's brainstorm",			name:          "Night cue",		{		},			expectedTime:  "Evening",			expectContext: true,			query:         "evening discussion about project",			name:          "Evening cue",		{		},			expectedTime:  "Afternoon",			expectContext: true,			query:         "last afternoon session",			name:          "Afternoon cue",		{		},			expectedTime:  "Morning",			expectContext: true,			query:         "yesterday morning meeting",			name:          "Morning cue",		{	}{		expectedDay    string		expectedTime   string		expectContext  bool		query          string		name           string	tests := []struct {	svc := service.NewContextualMetadataService()func TestContextualMetadataService_ExtractContextCue(t *testing.T) {}	}		})			t.Logf("✅ %s (%d:%02d) → %s", tt.name, tt.hour, tt.minute, context.TimeOfDay)			}				t.Errorf("GetCurrentContext() ChatSource = %v, want Telegram", context.ChatSource)			if context.ChatSource != "Telegram" {			}				t.Errorf("GetCurrentContext() DayOfWeek = %v, want Sunday", context.DayOfWeek)			if context.DayOfWeek != "Sunday" { // Dec 15, 2025 is Sunday			}					tt.hour, tt.minute, context.TimeOfDay, tt.expectedTimeOfDay)				t.Errorf("GetCurrentContext(%d:%02d) TimeOfDay = %v, want %v", 			if context.TimeOfDay != tt.expectedTimeOfDay {			context := svc.GetCurrentContext(testTime, "Telegram")						testTime := time.Date(2025, 12, 15, tt.hour, tt.minute, 0, 0, time.UTC)			// Create a timestamp with the specific hour		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {	}		{"Before dawn", 4, 59, "Night"},		{"Late night", 3, 30, "Night"},		{"Midnight", 0, 0, "Night"},		{"Early night", 21, 0, "Night"},		{"Late evening", 20, 59, "Evening"},		{"Mid evening", 19, 30, "Evening"},		{"Early evening", 17, 0, "Evening"},		{"Late afternoon", 16, 59, "Afternoon"},		{"Early afternoon", 13, 30, "Afternoon"},		{"Noon", 12, 0, "Afternoon"},		{"Late morning", 11, 59, "Morning"},		{"Mid morning", 9, 30, "Morning"},		{"Early morning", 5, 0, "Morning"},	}{		expectedTimeOfDay string		minute          int		hour            int		name            string	tests := []struct {	svc := service.NewContextualMetadataService()func TestContextualMetadataService_GetCurrentContext(t *testing.T) {)	"time"	"testing"